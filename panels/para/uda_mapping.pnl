V 13
4
LANG:10001 34 user dependent alert class mapping
LANG:10004 30 用户定义的报警类映射
LANG:10000 40 Benutzerabhängige Alarmklassenzuweisung
LANG:10027 77 Определение соответствия классов алармов
PANEL,-1 -1 508 515 N "_3DFace" 0
E E E E E 1 -1 -1 0  0 0
""0  1
E "#uses \"asModifyDisplay.ctl\"

dyn_string dsDPEs,dsOrigs,dsMapps;
mapping mData,mDataCompare,mDataNotToDelete;
string mDataKey;
const string sDefaultColorAliasDB = \"udaAliasColorDB\";
const string sUdaRealColorDefinitionPrefix = \"_uda_\";

// ============================================================================
// procedure:     setupTableRightSide()
// author:        wgernedl
// purpose:       retrieves alert classes for right table side depending on table left side selection of alert class 
// parameters:    row : table line
//                ackType : acknowledge type
//                value : cell value of left side cell
// returns:       none
// ============================================================================
void setupTableRightSide(int row, int ackType,string value)
{
  dyn_string dsAlertClass;
  
  dsAlertClass = readAlertClasses(ackType);//read alert classes fitting given acknowledge type
  dynUnique(dsAlertClass);
  int i = dynContains(dsAlertClass,value);
  if(i > 0)
  {
    dynRemove(dsAlertClass,i);
  }
  for(int i = 1; i <= dynlen(dsAlertClass); i++)
  {
    string s = dsAlertClass[i];
    dsAlertClass[i] = dynPatternMatch(\"*\"+s+\" (*\",dsMapps);
  }
  dynSortAsc(dsAlertClass);
  dynInsertAt(dsAlertClass,FALSE,1);
  TABLE1.cellWidgetRC(row,\"_mappedAC\", \"ComboBox\", dsAlertClass);//setup cell on right side of table row
}

// ============================================================================
// procedure:     readAlertClasses()
// author:        wgernedl
// purpose:       retrieves alert classes 
// parameters:    ackType : acknowledge type
// returns:       none
// ============================================================================
dyn_string readAlertClasses(int ackType, string operator = \" <= \")
{
  dyn_string dsAlertClass;
  dyn_dyn_anytype dda;
  string sQuery = \"SELECT '_alert_class.._ack_type' FROM '*' WHERE _DPT = \\\"_AlertClass\\\" AND  '_alert_class.._ack_type'\"+operator+ackType;
  
  dpQuery(sQuery,dda);
  for(int i = 2; i <= dynlen(dda); i++)
  {
    dynAppend(dsAlertClass,dpSubStr(dda[i][1],DPSUB_DP));
  }
  return dsAlertClass;//return results
}

// ============================================================================
// procedure:     deleteTableLines()
// author:        wgernedl
// purpose:       refresh table by deleting wasted lines
// parameters:    none
// returns:       none
// ============================================================================
void deleteTableLines()
{
  dyn_string dsAlertClass;
  
  for(int i = TABLE1.lineCount(); i > 1; i--)
  {
    string sOriginal = TABLE1.cellValueRC(i-1,\"origAC\");
    string sMapped   = TABLE1.cellValueRC(i-1,\"mappedAC\");
    if((sOriginal == \"\") && (sMapped == \"\"))//delete empty lines
      TABLE1.deleteLineN(i-1);
  }
  int i = TABLE1.lineCount(); 
  string sOriginal = (i>0)?TABLE1.cellValueRC(i-1,\"origAC\"):\"\";
  string sMapped   = (i>0)?TABLE1.cellValueRC(i-1,\"mappedAC\"):\"\";
  if((sOriginal != \"\") || (sMapped != \"\") || (i == 0))//setup an additional line at the end of table
  {
    TABLE1.insertLineN(i);
    dsAlertClass = dsOrigs;
    dynInsertAt(dsAlertClass,FALSE,1);
    TABLE1.cellWidgetRC(i,\"_origAC\", \"ComboBox\", dsAlertClass);
    dsAlertClass = dsMapps;
    dynInsertAt(dsAlertClass,FALSE,1);
    TABLE1.cellWidgetRC(i,\"_mappedAC\", \"ComboBox\", dsAlertClass);    
  }
}

// ============================================================================
// procedure:     setupMappingWithData()
// author:        wgernedl
// purpose:       store data into internal mapping
// parameters:    sDP : datapoint of type _UserDependingAlarms
//                dsOriginal : dyn string of original alert classes
//                dsMapped : dyn string of target alert classes
// returns:       none
// ============================================================================
void setupMappingWithData(string sDP, dyn_string dsOriginal, dyn_string dsMapped)
{
  mapping empty;
  
  if(!mappingHasKey(mData,sDP))
  {
     mData[sDP] = empty;
     mDataCompare[sDP] = empty;
  }
  if(!mappingHasKey(mData[sDP],\"original\"))
  {
     mDataCompare[sDP][\"original\"] = dsOriginal;
     mData[sDP][\"original\"] = dsOriginal;
  }
  if(!mappingHasKey(mData[sDP],\"mapped\"))
  {
     mDataCompare[sDP][\"mapped\"] = dsMapped;
     mData[sDP][\"mapped\"] = dsMapped;
  }
}

// ============================================================================
// procedure:     selectedUsrGroupOK()
// author:        wgernedl
// purpose:       check whether new selected group exists
// parameters:    new selection of user group
// returns:       TRUE:group exists / FALSE:group doesn't exist
// ============================================================================
bool selectedUsrGroupOK(string sNewSelection)
{
  dyn_string dsGroups = usrGrp.items;
  return dynContains(dsGroups,sNewSelection);
}

// ============================================================================
// procedure:     getIntoMapping()
// author:        wgernedl
// purpose:       setup internal mapping with data from table
// parameters:    m : mapping variable
//                sUsrGrp : name of usergroup
// returns:       none
// ============================================================================
void getIntoMapping(mapping &m, string sUsrGrp)
{
  mapping empty;
  
  if(!mappingHasKey(m,\"_UserDependingAlarms_\"+sUsrGrp))
    m[\"_UserDependingAlarms_\"+sUsrGrp] = empty;
  dyn_string dsOriginal, dsMapped;
  int iCnt=0;
  
  for(int i = 0; i < TABLE1.lineCount(); i++)
  {
    string sOriginal = TABLE1.cellValueRC(i,\"origAC\");
    string sMapped   = TABLE1.cellValueRC(i,\"mappedAC\");
    
    if(sOriginal != \"\" && sMapped != \"\")
    {
      dynAppend(dsOriginal,sOriginal);
      dynAppend(dsMapped,sMapped);
    }
  }
  for(int i = dynlen(dsOriginal); i > 0; i--)
  {
    if((dsOriginal[i] != \"\") && (dsOriginal[i] == dsMapped[i]))
    {
      //remove self assignments
      dynRemove(dsOriginal,i);
      dynRemove(dsMapped,i);
    }
  }
  m[\"_UserDependingAlarms_\"+sUsrGrp][\"original\"] = dsOriginal;
  m[\"_UserDependingAlarms_\"+sUsrGrp][\"mapped\"]   = dsMapped; 
}

// ============================================================================
// procedure:     saveMappingForUsrGroup()
// author:        wgernedl
// purpose:       save contents of mapping to datapoint
// parameters:    sUsrGrp : name of usergroup
// returns:       none
// ============================================================================
int saveMappingForUsrGroup(string sUsrGrp)
{
  if(!mappingHasKey(mData,\"_UserDependingAlarms_\"+sUsrGrp))
    setupMappingWithData(\"_UserDependingAlarms_\"+sUsrGrp, makeDynString(), makeDynString());
  
  dyn_string dsOriginal, dsMapped;
  int iCnt=0;
  
  for(int i = 0; i < TABLE1.lineCount(); i++)
  {
    string sOriginal = TABLE1.cellValueRC(i,\"origAC\");
    string sMapped   = TABLE1.cellValueRC(i,\"mappedAC\");
    
    if((sOriginal != \"\") && (sMapped != \"\"))
    {
      dynAppend(dsOriginal,sOriginal);
      dynAppend(dsMapped,sMapped);
    }
    else if(i < (TABLE1.lineCount()-1))//not for last table row
      iCnt++;//error : invalid table entry
  }
  for(int i = dynlen(dsOriginal); i > 0; i--)
  {
    if((dsOriginal[i] != \"\") && (dsOriginal[i] == dsMapped[i]))
    {
      iCnt++;//remove self assignments
      dynRemove(dsOriginal,i);
      dynRemove(dsMapped,i);
    }
  }
  mData[\"_UserDependingAlarms_\"+sUsrGrp][\"original\"] = dsOriginal;
  mData[\"_UserDependingAlarms_\"+sUsrGrp][\"mapped\"]   = dsMapped;
  for(int i = dynlen(dsOriginal); i > 0; i--)
  {
    if((dynlen(dsMapped) < i) || (dsMapped[i] == \"\") || (dsOriginal[i] == \"\"))
    {
      if(dynlen(dsMapped) >= i) dynRemove(dsMapped,i);
      if(dynle(dsOriginal) >= i) dynRemove(dsOriginal,i);
    }
  }
  saveDataToInternalDP(sUsrGrp,dsOriginal,dsMapped);
  return iCnt;//iCnt > 0 : there are invalid table entries
}

// ============================================================================
// procedure:     createColorScheme()
// author:        wgernedl
// purpose:       create directory for color scheme
// parameters:    sColorScheme : name of color scheme
// returns:       bool (TRUE == success)
// ============================================================================
bool createColorScheme(string sColorScheme)
{
  return mkdir(getPath(COLORDB_REL_PATH)+sColorScheme);
}

// ============================================================================
// procedure:     clearCache()
// author:        wgernedl
// purpose:       remove previous cached value of dpGetCache
// parameters:    dsOriginal : dyn_string of original alert classes
//                dsMapped : dyn_string of target alert classes
// returns:       none
// ============================================================================
private clearCache(dyn_string dsOriginal, dyn_string dsMapped)
{
  if(globalExists(\"g_dpGetCache\"))//Remove from cache
  {
    for(int i = 1; i <= dynlen(dsOriginal); i++)
    {
      dpRemoveCache(dsOriginal[i]);
    }
    for(int i = 1; i <= dynlen(dsMapped); i++)
    {
      dpRemoveCache(dsMapped[i]);
    }
  }
}

// ============================================================================
// procedure:     setColorsOfScheme()
// author:        wgernedl
// purpose:       build color aliases to show the original colors as target colors eg. alertCameUack --> warningCameUnack
// parameters:    sColorSchemeName : name of color scheme
//                dsOriginal : dyn_string with original alert classes
//                dsMapped : dyn_string with target alert classes
//                dsUpdatedAlias : list of updated color aliases
//                dsUpdatedColors : list of updated colors
//                deleteIt : bool, flag to delete previous defined aliases
// returns:       int 0 == success, others are error codes
// ============================================================================
int setColorsOfScheme(string sColorSchemeName, dyn_string dsOriginal, dyn_string dsMapped, dyn_string &dsUpdatedAlias, dyn_string &dsUpdatedColors, bool deleteIt=FALSE)
{
  string sIdent = myModuleName();
  clearCache(dsOriginal, dsMapped);
  mappingClear(mUsrDepAlarmSettings);
  aes_interfaceSetupSettingsNoMatrix(-1,-1,-1,-1,sIdent,sColorSchemeName);
  
  int errCnt = 0;
  
  DebugFTN(__FUNCTION__,sColorSchemeName, dsOriginal, dsMapped, deleteIt);
  
  dyn_string deletedColors;
  
  if(dynlen(dsOriginal) == dynlen(dsMapped))//there must be a target alert class for each original alert class
  {
    for(int i = 1; i <= dynlen(dsOriginal); i++)
    {
      string sNewColor,sAlias;

      if(mappingHasKey(mUsrDepAlarmSettings[sIdent],dsOriginal[i]) && mappingHasKey(mUsrDepAlarmSettings[sIdent],dsMapped[i]))
      {                 
        //Farbe für KAM/quittiert - Vordergrund
        sNewColor = (mUsrDepAlarmSettings[sIdent][dsMapped[i]][\":_alert_class.._fore_color_c_ack\"]!=\"\")?
                     mUsrDepAlarmSettings[sIdent][dsMapped[i]][\":_alert_class.._fore_color_c_ack\"]: mUsrDepAlarmSettings[sIdent][\"AEScolor\"];
        sAlias   = mUsrDepAlarmSettings[sIdent][dsOriginal[i]][\":_alert_class.._fore_color_c_ack\"];

        if((sAlias != \"\") && panelColorSetAlias(sColorSchemeName+\"/colors\",sAlias,sNewColor,deletedColors,dsUpdatedAlias,dsUpdatedColors,deleteIt))
        {
          errCnt++;
        }

        //Farbe für KAM/quittiert - Hintergrund
        sNewColor = (mUsrDepAlarmSettings[sIdent][dsMapped[i]][\":_alert_class.._color_c_ack\"]!=\"\")?
                     mUsrDepAlarmSettings[sIdent][dsMapped[i]][\":_alert_class.._color_c_ack\"]:\"_Transparent\";
        sAlias   = mUsrDepAlarmSettings[sIdent][dsOriginal[i]][\":_alert_class.._color_c_ack\"];
        
        if((sAlias != \"\") && panelColorSetAlias(sColorSchemeName+\"/colors\",sAlias,sNewColor,deletedColors,dsUpdatedAlias,dsUpdatedColors,deleteIt))
        {
          errCnt++;
        }
        /////////
        
        //Farbe für KAM/unquittiert - Vordergrund
        if(mUsrDepAlarmSettings[sIdent][dsMapped[i]][\":_alert_class.._fore_color_c_nack\"] != \"\")
          sNewColor = mUsrDepAlarmSettings[sIdent][dsMapped[i]][\":_alert_class.._fore_color_c_nack\"];
        else if(mUsrDepAlarmSettings[sIdent][dsMapped[i]][\":_alert_class.._fore_color_c_ack\"] != \"\")
          sNewColor = mUsrDepAlarmSettings[sIdent][dsMapped[i]][\":_alert_class.._fore_color_c_ack\"];
        else
          sNewColor = mUsrDepAlarmSettings[sIdent][\"AEScolor\"];
        sAlias   = mUsrDepAlarmSettings[sIdent][dsOriginal[i]][\":_alert_class.._fore_color_c_nack\"];
        
        if((sAlias != \"\") && panelColorSetAlias(sColorSchemeName+\"/colors\",sAlias,sNewColor,deletedColors,dsUpdatedAlias,dsUpdatedColors,deleteIt))
        {
          errCnt++;
        }

        //Farbe für KAM/unquittiert - Hintergrund
        sNewColor = (mUsrDepAlarmSettings[sIdent][dsMapped[i]][\":_alert_class.._color_c_nack\"]!=\"\")?
                     mUsrDepAlarmSettings[sIdent][dsMapped[i]][\":_alert_class.._color_c_nack\"]:mUsrDepAlarmSettings[sIdent][dsMapped[i]][\":_alert_class.._color_c_ack\"];
        sAlias   = mUsrDepAlarmSettings[sIdent][dsOriginal[i]][\":_alert_class.._color_c_nack\"];
        
        if((sAlias != \"\") && panelColorSetAlias(sColorSchemeName+\"/colors\",sAlias,sNewColor,deletedColors,dsUpdatedAlias,dsUpdatedColors,deleteIt))
        {
          errCnt++;
        }
        /////////
        
        //Farbe für GING/unquittiert - Vordergrund
        sNewColor = (mUsrDepAlarmSettings[sIdent][dsMapped[i]][\":_alert_class.._fore_color_g_nack\"]!=\"\")?
                     mUsrDepAlarmSettings[sIdent][dsMapped[i]][\":_alert_class.._fore_color_g_nack\"]:mUsrDepAlarmSettings[sIdent][\"AEScolor\"];
        sAlias   = mUsrDepAlarmSettings[sIdent][dsOriginal[i]][\":_alert_class.._fore_color_g_nack\"];
        
        if((sAlias != \"\") && panelColorSetAlias(sColorSchemeName+\"/colors\",sAlias,sNewColor,deletedColors,dsUpdatedAlias,dsUpdatedColors,deleteIt))
        {
          errCnt++;
        }

        //Farbe für GING/unquittiert - Hintergrund
        sNewColor = (mUsrDepAlarmSettings[sIdent][dsMapped[i]][\":_alert_class.._color_g_nack\"]!=\"\")?
                     mUsrDepAlarmSettings[sIdent][dsMapped[i]][\":_alert_class.._color_g_nack\"]:\"_Transparent\";
        sAlias   = mUsrDepAlarmSettings[sIdent][dsOriginal[i]][\":_alert_class.._color_g_nack\"];
        
        if((sAlias != \"\") && panelColorSetAlias(sColorSchemeName+\"/colors\",sAlias,sNewColor,deletedColors,dsUpdatedAlias,dsUpdatedColors,deleteIt))
        {
          errCnt++;
        }
        /////////
        
        //Farbe für KAM/GING/unquittiert - Vordergrund
        sNewColor = (mUsrDepAlarmSettings[sIdent][dsMapped[i]][\":_alert_class.._fore_color_c_g_nack\"]!=\"\")?
                     mUsrDepAlarmSettings[sIdent][dsMapped[i]][\":_alert_class.._fore_color_c_g_nack\"]:mUsrDepAlarmSettings[sIdent][\"AEScolor\"];
        sAlias   = mUsrDepAlarmSettings[sIdent][dsOriginal[i]][\":_alert_class.._fore_color_c_g_nack\"];
        
        if((sAlias != \"\") && panelColorSetAlias(sColorSchemeName+\"/colors\",sAlias,sNewColor,deletedColors,dsUpdatedAlias,dsUpdatedColors,deleteIt))
        {
          errCnt++;
        }

        //Farbe für KAM/GING/unquittiert - Hintergrund
        sNewColor = (mUsrDepAlarmSettings[sIdent][dsMapped[i]][\":_alert_class.._color_c_g_nack\"]!=\"\")?
                     mUsrDepAlarmSettings[sIdent][dsMapped[i]][\":_alert_class.._color_c_g_nack\"]:\"_Transparent\";
        sAlias   = mUsrDepAlarmSettings[sIdent][dsOriginal[i]][\":_alert_class.._color_c_g_nack\"];
        
        if((sAlias != \"\") && panelColorSetAlias(sColorSchemeName+\"/colors\",sAlias,sNewColor,deletedColors,dsUpdatedAlias,dsUpdatedColors,deleteIt))
        {
          errCnt++;
        }
        ////////
        
        //Farbe für Keine Meldung - Vordergrund
        sNewColor = (mUsrDepAlarmSettings[sIdent][dsMapped[i]][\":_alert_class.._fore_color_none\"]!=\"\")?
                     mUsrDepAlarmSettings[sIdent][dsMapped[i]][\":_alert_class.._fore_color_none\"]:mUsrDepAlarmSettings[sIdent][\"AEScolor\"];
        sAlias   = mUsrDepAlarmSettings[sIdent][dsOriginal[i]][\":_alert_class.._fore_color_none\"];
        
        if((sAlias != \"\") && panelColorSetAlias(sColorSchemeName+\"/colors\",sAlias,sNewColor,deletedColors,dsUpdatedAlias,dsUpdatedColors,deleteIt))
        {
          errCnt++;
        }

        //Farbe für Keine Meldung - Hintergrund
        sNewColor = (mUsrDepAlarmSettings[sIdent][dsMapped[i]][\":_alert_class.._color_none\"]!=\"\")?
                     mUsrDepAlarmSettings[sIdent][dsMapped[i]][\":_alert_class.._color_none\"]:\"_Transparent\";
        sAlias   = mUsrDepAlarmSettings[sIdent][dsOriginal[i]][\":_alert_class.._color_none\"];
        
        if((sAlias != \"\") && panelColorSetAlias(sColorSchemeName+\"/colors\",sAlias,sNewColor,deletedColors,dsUpdatedAlias,dsUpdatedColors,deleteIt))
        {
          errCnt++;
        }
        ////////
      }
    }
  }
  if(errCnt == 0)
    return 0;
  else if(deleteIt)
    return -3;
  return -2;
}

// ============================================================================
// procedure:     panelColorSetAlias()
// author:        wgernedl
// purpose:       define or delete color aliases 
// parameters:    sColorSchemeName : name of color scheme
//                sAlias : color alias
//                sNewColor : target of color alias
//                deletedColors : list of already deleted color aliases
//                dsUpdatedAlias : list of updated color aliases
//                dsUpdatedColors : list of updated colors
//                deleteIt : bool, flag to delete previous defined aliases
// returns:       int 0 == success, others are error codes
// ============================================================================
int panelColorSetAlias(string sColorSchemeName,string sAlias,string sNewColor, dyn_string &deletedColors, 
                       dyn_string &dsUpdatedAlias, dyn_string &dsUpdatedColors, bool deleteIt = FALSE)
{
  if(patternMatch(sUdaRealColorDefinitionPrefix+\"*\", \"_\"+sNewColor))
    sNewColor=\"_\"+sNewColor;

  if(deleteIt)
  {
    if(dynContains(deletedColors,sAlias))//color alias already deleted
      return 0;
    dynAppend(deletedColors,sAlias);
    if(isfile(getPath(COLORDB_REL_PATH,sColorSchemeName)))
    {
      string colorName;
      
      if(colorGetAlias(sColorSchemeName, sAlias, colorName) == 0)
        return colorRemove(sColorSchemeName,sAlias);//if alias exists
      else
        return 0;
    }
    else
      return 0;
  }
  else
  {
    if(patternMatch(\"{*}\",sNewColor))//absolute color definitions are not allowed
    {
      dyn_string ds;
      dyn_float df;
      string s;
      
      sprintf(s,getCatStr(\"usrDepAlarms\",\"00013\"),sNewColor);//unable to define a color alias to an absolute color definition
      ChildPanelOnCentralModalReturn(\"vision/MessageWarning\",myModuleName()+\"_UDA00013\",makeDynString(\"$1:\"+s),df,ds);      
      return -1;
    }
    else if((sNewColor != \"\") && (sAlias != sNewColor))
    {
      dynAppend(dsUpdatedAlias, sAlias);
      dynAppend(dsUpdatedColors, sNewColor);
      return colorSetAlias(sColorSchemeName,sAlias,sNewColor);
    }
  }
  return 0;
}

// ============================================================================
// procedure:     saveNewColorScheme()
// author:        wgernedl
// purpose:       define or delete color schemes 
// parameters:    sColorSchemeName : name of color scheme
//                dsOriginal : dyn_string of original alert classes
//                dsMapped : target list of alert classes
// returns:       int 0 == success, others are error codes
// ============================================================================
int saveNewColorScheme(string sColorSchemeName, dyn_string dsOriginal, dyn_string dsMapped, dyn_string &dsUpdatedAlias, dyn_string &dsUpdatedColors)
{
  string sPath  = getPath(COLORDB_REL_PATH);
  int retCode   = 0;
  
  if(!isdir(sPath+sColorSchemeName)) //color scheme does not exist
  {
    if(!createColorScheme(sColorSchemeName))
      retCode = -1;//could not create color scheme
    else
      retCode = setColorsOfScheme(sColorSchemeName, dsOriginal, dsMapped, dsUpdatedAlias, dsUpdatedColors);
  }
  else//color scheme exists
  {
    retCode = setColorsOfScheme(sColorSchemeName, dsOriginal, dsMapped, dsUpdatedAlias, dsUpdatedColors);
  }
  return retCode;
}

// ============================================================================
// procedure:     saveDataToInternalDP()
// author:        wgernedl
// purpose:       save the data of alert class mappint onto an internal datapoint
// parameters:    sUsrGrp : name of usergroup
//                dsOriginal : dyn_string of original alert classes
//                dsMapped : target list of alert classes
// returns:       none
// ============================================================================
void saveDataToInternalDP(string sUsrGrp, dyn_string dsOriginal, dyn_string dsMapped)
{
  if(!dpExists(\"_UserDependingAlarms_\"+sUsrGrp))
    dpCreate(\"_UserDependingAlarms_\"+sUsrGrp,\"_UserDependingAlarms\");
  dpSetCache(\"_UserDependingAlarms_\"+sUsrGrp+\".originalAlarmClass\",dsOriginal,
             \"_UserDependingAlarms_\"+sUsrGrp+\".alarmClass\",dsMapped);
  
  dyn_errClass dErr = getLastError();
  if(dynlen(dErr))
    errorDialog(dErr);
  else
    mDataCompare[\"_UserDependingAlarms_\"+sUsrGrp] = mData[\"_UserDependingAlarms_\"+sUsrGrp];
  
  dyn_string dsUpdatedAlias, dsUpdatedColors;
  int iRet;
  
  if((iRet = saveNewColorScheme(sUsrGrp,dsOriginal,dsMapped, dsUpdatedAlias, dsUpdatedColors)) < 0)//save new color scheme with color information of this user group
  {
    dyn_string ds;
    dyn_float df;
    string s;
    
    if(iRet == -1)
    {
      sprintf(s,getCatStr(\"usrDepAlarms\",\"00009\"),sUsrGrp);
      ChildPanelOnCentralModalReturn(\"vision/MessageWarning\",myModuleName()+\"_UDA00009\",makeDynString(\"$1:\"+s),df,ds);
      //could not create color scheme
    }
    else if(iRet == -2)
    {
      sprintf(s,getCatStr(\"usrDepAlarms\",\"00010\"),sUsrGrp);
      ChildPanelOnCentralModalReturn(\"vision/MessageWarning\",myModuleName()+\"_UDA00010\",makeDynString(\"$1:\"+s),df,ds);
      //could not create color alias      
    }
    else if(iRet == -3)
    {
      sprintf(s,getCatStr(\"usrDepAlarms\",\"00011\"),sUsrGrp);
      ChildPanelOnCentralModalReturn(\"vision/MessageWarning\",myModuleName()+\"_UDA00010\",makeDynString(\"$1:\"+s),df,ds);
      //could not delete color alias      
    }
  }
  
  //check if this should be the default configuration
  bool bUseAsDefault;
  getValue(\"cbDefaultConfig\", \"state\", 0, bUseAsDefault);
  if(bUseAsDefault)
  { //set this group as default configuration
    string sCurrentDefaultConfiguration;
    bool bIsDefaultConfigConfirmed = TRUE;
    
    dpGet(\"_UserDependingAlarmsSettings.defaultConfiguration\", sCurrentDefaultConfiguration);
    if((sCurrentDefaultConfiguration != \"\") && (sCurrentDefaultConfiguration != sUsrGrp))
    {
      dyn_string ds;
      dyn_float df;
      string s; 
      //Confirmation dialouge
      sprintf(s,getCatStr(\"usrDepAlarms\",\"00015\"),sCurrentDefaultConfiguration,sUsrGrp);
      ChildPanelOnCentralModalReturn(\"vision/MessageWarning2\",myModuleName()+\"_UDA00015\",makeDynString(\"$1:\"+s,
                                                                                                       getCatStr(\"general\",\"yes\"),
                                                                                                       getCatStr(\"general\",\"no\")),
                                     df,ds);
      bIsDefaultConfigConfirmed = (dynlen(df) && (df[1] == 1));
      
    } 
    if(bIsDefaultConfigConfirmed)
    {
      dpSetCache(\"_UserDependingAlarmsSettings.defaultConfiguration\", sUsrGrp);
      setDefaultConfigurationColorScheme(sUsrGrp, dsUpdatedAlias, dsUpdatedColors);
    }
  }
  else
  { //if this has been the default cofiguration but now it should be removed
    string sCurrentDefaultConfiguration;
    dpGet(\"_UserDependingAlarmsSettings.defaultConfiguration\", sCurrentDefaultConfiguration);
    if(sCurrentDefaultConfiguration==sUsrGrp) //reset
    {
      dpSetCache(\"_UserDependingAlarmsSettings.defaultConfiguration\", \"\");
      setDefaultConfigurationColorScheme(\"\", dsUpdatedAlias, dsUpdatedColors);
    }
  }
}

// ============================================================================
// procedure:     displayDataForUsrGrp()
// author:        wgernedl
// purpose:       display data of mapping in panel
// parameters:    sUsrGrp : name of usergroup
// returns:       none
// ============================================================================
void displayDataForUsrGrp(string sUsrGrp)
{
  if(!mappingHasKey(mData,\"_UserDependingAlarms_\"+sUsrGrp))
  {
    deleteTableLines();
    updateDefaultGroupCheckBox(\"\");
    return;//nothing to display
  }
  updateDefaultGroupCheckBox(sUsrGrp);
  mapping m = mData[\"_UserDependingAlarms_\"+sUsrGrp];
  dyn_string dsOriginal = m[\"original\"];
  dyn_string dsMapped   = m[\"mapped\"];
  dyn_string ds;

  TABLE1.deleteAllLines();
  for(int i = 1; i <= dynlen(dsOriginal); i++)//setup table rows
  {
    TABLE1.insertLineN(i-1);
    ds = dsOrigs;
    dynInsertAt(ds,FALSE,1);
    TABLE1.cellWidgetRC(i-1,\"_origAC\", \"ComboBox\", ds);
    ds = dsMapps;
    dynInsertAt(ds,FALSE,1);
    TABLE1.cellWidgetRC(i-1,\"_mappedAC\", \"ComboBox\", ds);
    TABLE1.cellFillRC(i-1,\"delete\",\"[pattern,[fit,any,StandardIcons/delete_20.png]]\");
    TABLE1.cellValueRC(i-1,\"origAC\",dsOriginal[i]);
    TABLE1.cellValueRC(i-1,\"mappedAC\",dsMapped[i]);
    //IM 118248 prio and abbrevation in userDependingAlarm mapping panel
    TABLE1.cellValueRC(i-1,\"_origAC\",getClassIdentOrigs(dsOriginal[i]));
    TABLE1.cellValueRC(i-1,\"_mappedAC\",getClassIdentMapps(dsMapped[i]));
  }
  if(TABLE1.lineCount())
    deleteTableLines();//delete wasted lines
  else
  {
    TABLE1.insertLineN(0);//add 1st line
    ds = dsOrigs;
    dynInsertAt(ds,FALSE,1);
    TABLE1.cellWidgetRC(0,\"_origAC\", \"ComboBox\", ds);
    ds = dsMapps;
    dynInsertAt(ds,FALSE,1);
    TABLE1.cellWidgetRC(0,\"_mappedAC\", \"ComboBox\", ds);    
  }
}

// ============================================================================
// procedure:     getClassFromIdent()
// author:        wgernedl
// purpose:       get the alert class name from displayed content
// parameters:    sIdent : displayed content e.g. 060_alert (A)
// returns:       alert class neme e.g. alert (from ident above)
// ============================================================================
string getClassFromIdent(string sIdent)
{
  string s = substr(sIdent,strpos(sIdent,\"_\")+1);
  dyn_string ds = strsplit(s,\" (\");
  return (dynlen(ds)?ds[1]:\"\");
}

// ============================================================================
// procedure:     getClassIdentOrigs()
// author:        wgernedl
// purpose:       find a corresponding list entry for original alert classes
// parameters:    sPattern : part of an identifier e.g. *alert* matches 060_alert (A) 
// returns:       alert class identifier e.g. 060_alert (A) for alert class \"alert\"
// ============================================================================
string getClassIdentOrigs(string sPattern)
{
  dyn_string ds = dynPatternMatch(\"*_\"+sPattern+\" (*\",dsOrigs);
  return (dynlen(ds) ? ds[1] : \"????\");
}

// ============================================================================
// procedure:     getClassIdentMapps()
// author:        wgernedl
// purpose:       find a list entry for target alert classes
// parameters:    sPattern : part of an identifier e.g. *alert* matches 060_alert (A)
// returns:       alert class identifier e.g. 060_alert (A) for alert class \"alert\"
// ============================================================================
string getClassIdentMapps(string sPattern)
{
  dyn_string ds = dynPatternMatch(\"*_\"+sPattern+\" (*\",dsMapps);
  return (dynlen(ds) ? ds[1] : \"????\");
}

// ============================================================================
// procedure:     checkOrigACforMultiples()
// author:        wgernedl
// purpose:       check multiple entries on left table side
// parameters:    sOriginal : name of alert class which must be unique on left table side
//                sMessage : message displayed in case of error
// returns:       bool : TRUE == sOriginal is not unique
// ============================================================================
bool checkOrigACforMultiples(string sOriginal = \"\", string sMessage = \"\")
{
  int iCnt=0;

  for(int i = 0; i < TABLE1.lineCount(); i++)
  {    
    if(sOriginal == \"\")//Rekursion
    {
      string sToCheck = TABLE1.cellValueRC(i,\"origAC\");
      if((sToCheck != \"\") && checkOrigACforMultiples(sToCheck,sMessage))
        return TRUE;
      else
        continue;
    }
    if(TABLE1.cellValueRC(i,\"origAC\") == sOriginal)
      iCnt++;
    if(iCnt > 1)
    {
      string s,sFormat = (sMessage != \"\")?sMessage+\" \":\"\";
      sprintf(s,sFormat+getCatStr(\"usrDepAlarms\",\"0001\"),sOriginal);
      dyn_string df;
      dyn_string ds;
      ChildPanelOnCentralModalReturn(\"vision/MessageInfo1\",myModuleName()+\"_UDA0001\",makeDynString(\"$1:\"+s),df,ds);
      return TRUE;;
    }
  }
  return FALSE;
}

// ============================================================================
// procedure:     checkRecursiveAssignment()
// purpose:       check if a recursion for alert classes is defined
// parameters:    sMessage : message displayed in case of error
// returns:       bool : TRUE == recursion is defined
// ============================================================================

bool checkRecursiveAssignment(string sOriginal = \"\", string sMessage = \"\")
{
  dyn_string ds_origAlertClass, ds_mappedAlertClass;
  bool b_recursion;
  int i;

  getValue(\"TABLE1\",\"getColumnN\",1,ds_origAlertClass);
  getValue(\"TABLE1\",\"getColumnN\",3,ds_mappedAlertClass);
  
  // read every entry from the left table of alert classes
  for(i=1;i<dynlen(ds_origAlertClass);i++)
  {
    if(ds_origAlertClass[i] != \"\")
    {
      string s_origAlertClass, s_mappedAlertClass;
      int i_index;
    
      s_origAlertClass = ds_origAlertClass[i];
      s_mappedAlertClass = ds_mappedAlertClass[i];

      // check if the alert class is also used as mapped alert class
      i_index = dynContains(ds_origAlertClass,s_mappedAlertClass);
    
      if(i_index > 0)
      {
        bool b_ret;

        // call the sub function checkRecursion
        b_ret = checkRecursion(ds_origAlertClass,ds_mappedAlertClass,s_origAlertClass,i);
              
        if(b_ret == 1)
        {
          b_recursion = 1;
          break;
        }
      }
    }
  }

  // open a warning dialog if a recursion was found
  if(b_recursion == 1)
  {
    string s,sFormat = (sMessage != \"\")?sMessage+\" \":\"\";
    sprintf(s,sFormat+getCatStr(\"usrDepAlarms\",\"00020\"),sOriginal);
    dyn_string df;
    dyn_string ds;
    ChildPanelOnCentralModalReturn(\"vision/MessageInfo1\",myModuleName()+\"_UDA0001\",makeDynString(\"$1:\"+s),df,ds);
    return TRUE;;
  }
  return FALSE;
}

// ============================================================================
// procedure:     checkRecursion()
// purpose:       sub function to check if a recursion for alert classes is defined
// parameters:    ds_origAlertClass:   list of original alert classes
//                ds_mappedAlertClass: list of mapped alert classes
//                s_alertClass:        alert class
//                i_index:             index
// returns:       bool : TRUE == recursion is defined
// ============================================================================

bool checkRecursion(dyn_string ds_origAlertClass, dyn_string ds_mappedAlertClass, string s_alertClass, int i_index)
{
  string s_mappedAlertClass;
  
  s_mappedAlertClass = ds_mappedAlertClass[i_index];

  // check array for recursive entries
  // compare the mapped alert class with the original alert class
  while(s_mappedAlertClass != s_alertClass)
  {
    int i_indexRecursion;
    
    // get the index for the mapped alert class from the list of original alert classes
    i_indexRecursion = dynContains(ds_origAlertClass,s_mappedAlertClass);

    // read the information for the mapped alert class
    if(i_indexRecursion > 0)
    {
      // get the new mapped alert class
      s_mappedAlertClass = ds_mappedAlertClass[i_indexRecursion];

      // remove the entries from the arrays
      dynRemove(ds_origAlertClass,i_index);
      dynRemove(ds_mappedAlertClass,i_index);
    }
    // if no recursion is found the value false is returned
    else
    {
      return false;
    }
  }
  // if a recursion is found the value true is returned
  return true;
}
    
// ============================================================================
// procedure:     checkSelfAssignment()
// author:        wgernedl
// purpose:       check mapping for self assignment
// parameters:    row : index of table row
// returns:       bool : TRUE == self assignment found
// ============================================================================
bool checkSelfAssignment(int row)
{
  if(row < 0) return FALSE;
  
  string sOriginal = TABLE1.cellValueRC(row,\"origAC\");
  string sMapped   = TABLE1.cellValueRC(row,\"mappedAC\");
  
  if((sOriginal != \"\") && (sOriginal == sMapped))
  {
    dyn_string ds;
    dyn_float df;
    
    ChildPanelOnCentralModalReturn(\"vision/MessageInfo1\",myModuleName()+\"_UDA0005\",makeDynString(\"$1:\"+getCatStr(\"usrDepAlarms\",\"0005\")),df,ds);
    return TRUE;//identical entry at table left and right side
  }
  return checkIfACexisting(sOriginal,sMapped,row);
}

// ============================================================================
// procedure:     checkIfACexisting()
// author:        wgernedl
// purpose:       check whether original or target alert classes exist
// parameters:    sOriginal : entry of table left side
//                sMapped : entry of table right side
//                row : index of table row
// returns:       bool : TRUE == either original or target alert class does not exist
// ============================================================================
bool checkIfACexisting(string sOriginal,string sMapped,int row)
{
  if((sOriginal != \"\") && !dpExists(sOriginal))//original AC does not exist
  {
    dyn_string ds;
    dyn_float df;
    string s;

    sprintf(s,getCatStr(\"usrDepAlarms\",\"00012\"),sOriginal);
    ChildPanelOnCentralModalReturn(\"vision/MessageWarning\",myModuleName()+\"_UDA0012\",makeDynString(\"$1:\"+s),df,ds);
    setValue(\"TABLE1\",\"cellValueRC\",row,\"origAC\",\"\",
                      \"cellValueRC\",row,\"_origAC\",\"\");
    return TRUE;//original alert class does not exist
  }
  else if((sMapped != \"\") && !dpExists(sMapped))
  {
    dyn_string ds;
    dyn_float df;
    string s;
    
    sprintf(s,getCatStr(\"usrDepAlarms\",\"00012\"),sMapped);
    ChildPanelOnCentralModalReturn(\"vision/MessageWarning\",myModuleName()+\"_UDA0012\",makeDynString(\"$1:\"+s),df,ds);
    setValue(\"TABLE1\",\"cellValueRC\",row,\"mappedAC\",\"\",
                      \"cellValueRC\",row,\"_mappedAC\",\"\");
    return TRUE;//target alert class does not exist
  }
  return FALSE;
}

// ============================================================================
// procedure:     saveAllEntries()
// author:        wgernedl
// purpose:       save table entries
// parameters:    none
// returns:       bool : TRUE == successful
// ============================================================================
bool saveAllEntries()
{
  return saveThisEntry();//save actual displayed data
}

// ============================================================================
// procedure:     saveThisEntry()
// author:        wgernedl
// purpose:       save actual displayed data
// parameters:    none
// returns:       bool : TRUE == successful
// ============================================================================
bool saveThisEntry()
{
  dyn_string dsUpdatedAlias, dsUpdatedColors;
  if(checkOrigACforMultiples(\"\",getCatStr(\"usrDepAlarms\",\"0002\")))//check table left side for multiple assignments of an alert class
  {
    return FALSE;//do not close panel
  }
  
  // check if a recursion of alert classes is defined
  if(checkRecursiveAssignment(\"\",getCatStr(\"usrDepAlarms\",\"0002\")))
  {
    return FALSE;//do not close panel
  }
  
  // save config
  if(mappingHasKey(mData,\"_UserDependingAlarms_\"+mDataKey) && mappingHasKey(mDataNotToDelete,\"_UserDependingAlarms_\"+mDataKey))
  {
    mapping m1 = mData[\"_UserDependingAlarms_\"+mDataKey];
    mapping m2 = mDataNotToDelete[\"_UserDependingAlarms_\"+mDataKey];
    for(int i = 1; i <= dynlen(m1[\"original\"]); i++)
      if(i > dynlen(m2[\"original\"]))
        setColorsOfScheme(mDataKey, makeDynString(m1[\"original\"][i]), makeDynString(m1[\"mapped\"][i]), dsUpdatedAlias, dsUpdatedColors, TRUE);
  }
  
  int iRet;
  dyn_string ds;
  dyn_float df;
  
  iRet = saveMappingForUsrGroup(mDataKey);
  switch(iRet)
  {           //there are no valid table entries
    case -1 : ChildPanelOnCentralModalReturn(\"vision/MessageInfo1\",myModuleName()+\"_UDA0003\",makeDynString(\"$1:\"+getCatStr(\"usrDepAlarms\",\"0003\")),df,ds);
              break;
    case  0 : break;//successfully saved
              //invalid table entries were removed before saving data
    default : ChildPanelOnCentralModalReturn(\"vision/MessageInfo1\",myModuleName()+\"_UDA0004\",makeDynString(\"$1:\"+getCatStr(\"usrDepAlarms\",\"0004\")),df,ds);
  }
  mDataCompare[\"_UserDependingAlarms_\"+mDataKey] = mData[\"_UserDependingAlarms_\"+mDataKey];
  return TRUE;//close panel
}

// ============================================================================
// procedure:     updateDefaultGroupCheckBox()
// author:        mtrummer
// purpose:       display via checkbox if the selected group is used as default configuration
// parameters:    user group
// returns:       -
// ============================================================================
void updateDefaultGroupCheckBox(string sUsrGrp)
{
  if(sUsrGrp==\"\")
    cbDefaultConfig.state(0,false);
  else if(dpExists(\"_UserDependingAlarmsSettings\"))
  {
    string sDefaultConfigName; //get default group name
    dpGet(\"_UserDependingAlarmsSettings.defaultConfiguration\", sDefaultConfigName);
    cbDefaultConfig.state(0,sDefaultConfigName == sUsrGrp);
  }
}

// ============================================================================
// procedure:     setDefaultConfigurationColorScheme()
// author:        mtrummer
// purpose:       configure default colors (alias colorDB)
// parameters:    user group, if it is set to \"\", the default group configuraion has been removed and will be resetted
//                dsUpdatedAlias : list of updated color aliases
//                dsUpdatedColors : list of updated colors
// returns:       -
// ============================================================================
setDefaultConfigurationColorScheme(string sDefaultGroup, dyn_string dsUpdatedAlias=makeDynString(), dyn_string dsUpdatedColors=makeDynString())
{  
  dyn_string dsExistingUdaColors = ColorNames(); //read all colors
  dyn_string dsAliasNames;

  for(int i=dynlen(dsExistingUdaColors); i>0; i--)
  { //color does not start with \"uda_\"
    if(!patternMatch(sUdaRealColorDefinitionPrefix+\"*\", dsExistingUdaColors[i]))
      dynRemove(dsExistingUdaColors, i);
    else //add default alias (remove beginning \"_\")
      dynInsertAt(dsAliasNames, substr(dsExistingUdaColors[i], 1), 1);
  }  
  
  if(sDefaultGroup!=\"\") //default group has been specified  
  {
    //get all scheme alias definitions and add to dsExistingUdaColors and dsAliasNames
    for(int i=1; i<=dynlen(dsUpdatedAlias); i++)
    { //ower write alias defintions with the ones of the users group
      int iPos = dynContains(dsAliasNames, dsUpdatedAlias[i]);
      if(iPos>0)
      {
        dsExistingUdaColors[iPos] = dsUpdatedColors[i];
      }
    }
  }
  
  //create alias for each color starting with \"_\"
  string sFileName = getPath(COLORDB_REL_PATH,sDefaultColorAliasDB);
  int iRes;
  if(sFileName!=\"\") //file does exists
    iRes = remove(sFileName);
  else
    sFileName = getPath(COLORDB_REL_PATH)+sDefaultColorAliasDB;
  
  for(int i=1; i<=dynlen(dsAliasNames); i++)
  {
    colorSetAlias(sFileName, dsAliasNames[i], dsExistingUdaColors[i]);
  }
}












" 0
 3
"CBRef" "1"
"EClose" "main()
{
  getIntoMapping(mData, usrGrp.text());
  if(mappingHasKey(mData,\"_UserDependingAlarms_\"+mDataKey) && mappingHasKey(mDataCompare,\"_UserDependingAlarms_\"+mDataKey) &&
     (mData[\"_UserDependingAlarms_\"+mDataKey] != mDataCompare[\"_UserDependingAlarms_\"+mDataKey]))
  {
    dyn_float df; //data changed - save ? Yes, No
    dyn_string ds;

    ChildPanelOnCentralModalReturn(\"vision/MessageInfo\",myModuleName()+\"_UDA0006\",makeDynString(\"$1:\"+getCatStr(\"usrDepAlarms\",\"0006\"),
                                                                                                    \"$2:\"+getCatStr(\"general\",\"yes\"),
                                                                                                    \"$3:\"+getCatStr(\"general\",\"no\")),df,ds);
    if(dynlen(df) && (df[1] != 0))
    {
      saveThisEntry();//save data
    }
  }
  PanelOff();
}" 0

"dpi" "96"
0 0 0
""
DISPLAY_LAYER, 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
LAYER, 0 
3
LANG:10000 0 
LANG:10001 0 
LANG:10027 0 
22 1
"usrGrp"
""
1 230 111.5 E E E 1 E 1 E N "_WindowText" E N "_Window" E E
 E E
1 0 0 0 0 0
E E E
0
3
LANG:10000 0 
LANG:10001 0 
LANG:10027 0 

0
4
LANG:10001 26 Arial,-1,13,5,50,0,0,0,0,0
LANG:10004 26 Arial,-1,13,5,50,0,0,0,0,0
LANG:10000 26 Arial,-1,13,5,50,0,0,0,0,0
LANG:10027 26 Arial,-1,13,5,50,0,0,0,0,0
0  313 133 497 159
0

"main()
{
  //if no special default configuration is set, update udaAliasColorDB
  string sDefaultConfiguraion;
  dpGet(\"_UserDependingAlarmsSettings.defaultConfiguration\", sDefaultConfiguraion);
  if(sDefaultConfiguraion==\"\")
  {
    setDefaultConfigurationColorScheme(\"\");
  }    
    
  dyn_string dsGroups;
  
  dpGet(\"_Groups.UserName\",dsGroups);//get usergroup
  
  this.items = dsGroups;
  this.text = dynlen(dsGroups)?dsGroups[1]:\"\";
  if(dynlen(dsGroups) == 0)//there are no existing user groups
  {
    //error --> message & close panel
    ChildPanelOnCentralModalReturn(\"vision/MessageWarning\",myModuleName()+\"_UDA00018\",makeDynString(\"$1:\"+getCatStr(\"usrDepAlarms\",\"00018\")),df,ds);      
    PanelOff();
  }
  
  dyn_string dsDP = dpNames(\"*\",\"_UserDependingAlarms\");
  
  for(int i = 1; i <= dynlen(dsGroups); i++)
  {
    dyn_string dsUsrDepAlarm = dynPatternMatch(\"*_\"+dsGroups[i],dsDP);
      
    if(dynlen(dsUsrDepAlarm))//there is one
    {
      dyn_string dsOriginal,dsMapped;
      dpGet(dpSubStr(dsUsrDepAlarm[1],DPSUB_DP)+\".alarmClass\",dsMapped,
            dpSubStr(dsUsrDepAlarm[1],DPSUB_DP)+\".originalAlarmClass\",dsOriginal);
      setupMappingWithData(dpSubStr(dsUsrDepAlarm[1],DPSUB_DP),dsOriginal,dsMapped);
    }
    else
      setupMappingWithData(\"_UserDependingAlarms_\"+dsGroups[i],makeDynString(),makeDynString());
  }
  displayDataForUsrGrp(this.text());
  mDataKey = this.text();
}





" 0

"main()
{
  //because of any unknown reasons this event sometimes is fired twice !!!
  usergroupChanged();//synchronize this function call
}

synchronized usergroupChanged()
{
  mapping m;
  dyn_float df;   
  dyn_string ds;

  if(!selectedUsrGroupOK(this.text()))
  {
    //usergroup does not exist
    string s;
    //error message
    sprintf(s,getCatStr(\"usrDepAlarms\",\"0019\"),this.text());
    ChildPanelOnCentralModalReturn(\"vision/MessageWarning\",myModuleName()+\"_UDA0019\",makeDynString(\"$1:\"+s),df,ds);
    this.text = mDataKey;//display previous selected group
    return;
  }
  
  getIntoMapping(m,mDataKey);
  
  if(m[\"_UserDependingAlarms_\"+mDataKey] != mDataCompare[\"_UserDependingAlarms_\"+mDataKey])
  {
    //data changed - save ? Yes, No
    ChildPanelOnCentralModalReturn(\"vision/MessageInfo\",myModuleName()+\"_UDA0006\",makeDynString(\"$1:\"+getCatStr(\"usrDepAlarms\",\"0006\"),
                                                                                                \"$2:\"+getCatStr(\"general\",\"yes\"),
                                                                                                \"$3:\"+getCatStr(\"general\",\"no\")),df,ds);
    if(dynlen(df) && (df[1] != 0))
    {
      saveThisEntry();//save data
    }
  }
  TABLE1.deleteAllLines();
  mDataKey = this.text();
  displayDataForUsrGrp(mDataKey);//display data for usergroup
}

" 0

E
 1 0
2 2
"PRIMITIVE_TEXT1"
""
1 210 137 E E E 1 E 1 E N "_WindowText" E N "_Window" E E
 E E
2 0 0 0 0 0
E E E
0
3
LANG:10000 0 
LANG:10001 0 
LANG:10027 0 

3
"sizePolicy" "Fixed Fixed"
"dashclr"N "_Transparent"
"antiAliased" "0"
E E 0 1 1 2 1 E U  0 E 210 137 303 152
0 2 2 "0s" 0 0 0 192 0 0  210 137 1
4
LANG:10001 26 Arial,-1,13,5,50,0,0,0,0,0
LANG:10004 26 Arial,-1,13,5,50,0,0,0,0,0
LANG:10000 26 Arial,-1,13,5,50,0,0,0,0,0
LANG:10027 26 Arial,-1,13,5,50,0,0,0,0,0
0 4
LANG:10001 9 Usergroup
LANG:10004 9 用户组
LANG:10000 14 Benutzergruppe
LANG:10027 23 Польз.группа
1 120 0 "" 0
0
13 104
"cancel"
""
1 413 478 E E E 1 E 1 E N "_ButtonText" E N "_Button" E E
 E E
20 0 0 0 27 0
E E E
0
4
LANG:10001 31 Discard changes and close panel
LANG:10004 27 放弃更改并关闭面板
LANG:10000 42 Änderungen verwerfen und Panel schließen
LANG:10027 66 Отменить изменения и закрыть панель

0
4
LANG:10001 26 arial,-1,13,5,50,0,0,0,0,0
LANG:10004 26 arial,-1,13,5,50,0,0,0,0,0
LANG:10000 26 arial,-1,13,5,50,0,0,0,0,0
LANG:10027 26 arial,-1,13,5,50,0,0,0,0,0
0  413 478 501 506

T 
4
LANG:10001 6 Cancel
LANG:10004 6 取消
LANG:10000 9 Abbrechen
LANG:10027 16 Отменить
"main()
{
  getIntoMapping(mData, usrGrp.text());
  if(mData[\"_UserDependingAlarms_\"+mDataKey] != mDataCompare[\"_UserDependingAlarms_\"+mDataKey])
  {
    dyn_float df; //data changed - save ? Yes, No
    dyn_string ds;

    ChildPanelOnCentralModalReturn(\"vision/MessageInfo\",myModuleName()+\"_UDA0006\",makeDynString(\"$1:\"+getCatStr(\"usrDepAlarms\",\"0006\"),
                                                                                                    \"$2:\"+getCatStr(\"general\",\"yes\"),
                                                                                                    \"$3:\"+getCatStr(\"general\",\"no\")),df,ds);
    if(dynlen(df) && (df[1] != 0))
    {
      saveThisEntry();//save data
    }
  }
  PanelOff();
}



" 0
 E E E
13 105
"ok"
""
1 233 478 E E E 1 E 1 E N "_ButtonText" E N "_Button" E E
 E E
21 0 0 0 0 0
E E E
0
4
LANG:10001 30 Accept changes and close panel
LANG:10004 15 保存并关闭
LANG:10000 44 Änderungen übernehmen und Panel schließen
LANG:10027 64 Принять изменения и закрыть панель

0
4
LANG:10001 26 arial,-1,13,5,50,0,0,0,0,0
LANG:10004 26 arial,-1,13,5,50,0,0,0,0,0
LANG:10000 26 arial,-1,13,5,50,0,0,0,0,0
LANG:10027 26 arial,-1,13,5,50,0,0,0,0,0
0  233 478 321 506

T 
4
LANG:10001 2 OK
LANG:10004 6 确定
LANG:10000 2 OK
LANG:10027 2 OK
"main()
{
  if(saveAllEntries())//save data and close panel
    PanelOff();
}

" 0
 E E E
13 106
"save"
""
1 323 478 E E E 1 E 1 E N "_ButtonText" E N "_Button" E E
 E E
22 0 0 0 0 0
E E E
0
4
LANG:10001 14 Accept changes
LANG:10004 12 接受更改
LANG:10000 23 Änderungen übernehmen
LANG:10027 37 Применить изменения

0
4
LANG:10001 26 arial,-1,13,5,50,0,0,0,0,0
LANG:10004 26 arial,-1,13,5,50,0,0,0,0,0
LANG:10000 26 arial,-1,13,5,50,0,0,0,0,0
LANG:10027 26 arial,-1,13,5,50,0,0,0,0,0
0  323 478 411 506

T 
4
LANG:10001 5 Apply
LANG:10004 6 应用
LANG:10000 11 Übernehmen
LANG:10027 18 Применить
"main()
{
  saveThisEntry();//save data
  mDataKey = usrGrp.text();
  displayDataForUsrGrp(mDataKey);//refresh table
}

" 0
 E E E
13 107
"Button1"
""
1 8 478 E E E 1 E 1 E N "_ButtonText" E N "_Button" E E
 E E
23 0 0 0 112 0
E E E
0
4
LANG:10001 16 Open online help
LANG:10004 18 打开在线帮助
LANG:10000 20 Online Hilfe öffnen
LANG:10027 14 Справка

0
4
LANG:10001 26 arial,-1,13,5,50,0,0,0,0,0
LANG:10004 26 arial,-1,13,5,50,0,0,0,0,0
LANG:10000 26 arial,-1,13,5,50,0,0,0,0,0
LANG:10027 26 arial,-1,13,5,50,0,0,0,0,0
0  8 478 96 506

T 
4
LANG:10001 4 Help
LANG:10004 6 帮助
LANG:10000 5 Hilfe
LANG:10027 14 Справка
"main()
{
  string path = getPath(HELP_REL_PATH,\"UserDependent_Alerts.pdf\");
  std_help(path);
}

" 0
 E E "main()
{
  if(isfile(getPath(HELP_REL_PATH,\"UserDependent_Alerts.pdf\")))//check help file if existing
  {
    this.enabled(true);//enable help button when help file is existing
  }
}

" 0

6 110
"RECTANGLE3"
""
1 0 80 E E E 1 E 1 E N {0,0,0} E N "_Window" E E
 E E
24 0 0 0 0 0
E E E
1
3
LANG:10000 0 
LANG:10001 0 
LANG:10027 0 

2
"dashclr"N "_Transparent"
"antiAliased" "0"
E E 0 1 1 2 1 E 0.5802204529391433 0 0.9 -0.1781701444622793 48 1 E 0 80 880 -50
2 112
"PRIMITIVE_TEXT5"
""
1 8 10 E E E 1 E 1 E N "_WindowText" E N "_Window" E E
 E E
26 0 0 0 0 0
E E E
0
3
LANG:10000 0 
LANG:10001 0 
LANG:10027 0 

3
"sizePolicy" "Fixed Fixed"
"dashclr"N "_Transparent"
"antiAliased" "0"
E E 0 1 1 2 1 E U  0 E 8 10 403 40
0 2 2 "0s" 0 0 0 64 0 0  8 10 1
4
LANG:10001 33 MS Shell Dlg,-1,13,5,75,0,0,0,0,0
LANG:10004 33 MS Shell Dlg,-1,13,5,75,0,0,0,0,0
LANG:10000 26 Arial,-1,13,5,75,0,0,0,0,0
LANG:10027 26 Arial,-1,13,5,75,0,0,0,0,0
0 4
LANG:10001 41 Definition of userdependent alert classes
LANG:10004 30 用户相关报警类的定义
LANG:10000 46 Zuweisung von benutzerabhängigen Alarmklassen
LANG:10027 77 Определение соответствия классов алармов
2 113
"shortdesc"
""
1 9 33.5 E E E 1 E 1 E N "_WindowText" E N "_Window" E E
 E E
27 0 0 0 0 0
E E E
0
3
LANG:10000 0 
LANG:10001 0 
LANG:10027 0 

3
"sizePolicy" "Fixed Fixed"
"dashclr"N "_Transparent"
"antiAliased" "0"
E E 0 1 1 2 1 E U  0 E 9 33.5 394 257
0 1 1 "0s" 0 0 0 192 0 0  9 33.5 15
4
LANG:10001 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10004 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10000 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10027 26 Arial,-1,11,5,75,0,0,0,0,0
0 4
LANG:10001 65 The original alert class is configured on the datapoint element. 
LANG:10004 45 在datapoint元素上配置原始警报类。
LANG:10000 65 Die originale Alarmklasse wird am Datenpunktelement konfiguriert.
LANG:10027 142 Исходный (основной) класс алармов устанавливается для элемента точки данных. 
4
LANG:10001 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10004 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10000 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10027 26 Arial,-1,11,5,75,0,0,0,0,0
0 4
LANG:10001 67 For user groups, alarms can be shown with different alert classes. 
LANG:10004 63 对于用户组，可以使用不同的警报类显示警报。
LANG:10000 51 Für einzelne Benutzergruppen kann eine abweichende
LANG:10027 122 Алармы могут отображаться с различными дополнительными классами, 
4
LANG:10001 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10004 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10000 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10027 26 Arial,-1,11,5,75,0,0,0,0,0
0 4
LANG:10001 42 Define this mapping for user groups below.
LANG:10004 39 为下面的用户组定义此映射。
LANG:10000 53 Alarmklasse angezeigt werden. Die Zuordnung zwischen 
LANG:10027 126 в зависимости от группы пользователей. Соответствие между исходными
4
LANG:10001 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10004 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10000 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10027 26 Arial,-1,11,5,75,0,0,0,0,0
0 4
LANG:10001 0 
LANG:10004 0 
LANG:10000 47 originaler und benutzerabhängiger Alarmklasse 
LANG:10027 128 и дополнительными классами алармов может быть указано в таблице ниже.
4
LANG:10001 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10004 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10000 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10027 26 Arial,-1,11,5,75,0,0,0,0,0
0 4
LANG:10001 0 
LANG:10004 0 
LANG:10000 68 kann für einzelne Benutzergruppen in der Tabelle festgelegt werden.
LANG:10027 0 
4
LANG:10001 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10004 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10000 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10027 26 Arial,-1,11,5,75,0,0,0,0,0
0 4
LANG:10001 0 
LANG:10004 0 
LANG:10000 0 
LANG:10027 0 
4
LANG:10001 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10004 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10000 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10027 26 Arial,-1,11,5,75,0,0,0,0,0
0 4
LANG:10001 0 
LANG:10004 0 
LANG:10000 0 
LANG:10027 0 
4
LANG:10001 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10004 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10000 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10027 26 Arial,-1,11,5,75,0,0,0,0,0
0 4
LANG:10001 0 
LANG:10004 0 
LANG:10000 0 
LANG:10027 0 
4
LANG:10001 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10004 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10000 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10027 26 Arial,-1,11,5,75,0,0,0,0,0
0 4
LANG:10001 0 
LANG:10004 0 
LANG:10000 0 
LANG:10027 0 
4
LANG:10001 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10004 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10000 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10027 26 Arial,-1,11,5,75,0,0,0,0,0
0 4
LANG:10001 0 
LANG:10004 0 
LANG:10000 0 
LANG:10027 0 
4
LANG:10001 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10004 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10000 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10027 26 Arial,-1,11,5,75,0,0,0,0,0
0 4
LANG:10001 0 
LANG:10004 0 
LANG:10000 0 
LANG:10027 0 
4
LANG:10001 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10004 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10000 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10027 26 Arial,-1,11,5,75,0,0,0,0,0
0 4
LANG:10001 0 
LANG:10004 0 
LANG:10000 0 
LANG:10027 0 
4
LANG:10001 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10004 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10000 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10027 26 Arial,-1,11,5,75,0,0,0,0,0
0 4
LANG:10001 0 
LANG:10004 0 
LANG:10000 0 
LANG:10027 0 
4
LANG:10001 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10004 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10000 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10027 26 Arial,-1,11,5,75,0,0,0,0,0
0 4
LANG:10001 0 
LANG:10004 0 
LANG:10000 0 
LANG:10027 0 
4
LANG:10001 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10004 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10000 26 Arial,-1,11,5,75,0,0,0,0,0
LANG:10027 26 Arial,-1,11,5,75,0,0,0,0,0
0 4
LANG:10001 0 
LANG:10004 0 
LANG:10000 0 
LANG:10027 0 
20 116
"cbDefaultConfig"
""
1 20 130.25 E E E 1 E 1 E N "_3DText" E N "_3DFace" E E
 E E
28 0 0 0 0 0
E E E
0
3
LANG:10000 0 
LANG:10001 0 
LANG:10027 0 

0
4
LANG:10001 26 Arial,-1,13,5,50,0,0,0,0,0
LANG:10004 26 Arial,-1,13,5,50,0,0,0,0,0
LANG:10000 26 Arial,-1,13,5,50,0,0,0,0,0
LANG:10027 26 Arial,-1,13,5,50,0,0,0,0,0
0  18 128 162 162
1
T 
4
LANG:10001 21 default configuration
LANG:10004 12 默认配置
LANG:10000 21 Default Konfiguration
LANG:10027 33 конф. по умолчанию

0 
3
LANG:10000 0 
LANG:10001 0 
LANG:10027 0 
E E
0 0 0 0 0
0
EE25 88
"TABLE1"
""
1 10.11882914876074 169 E E E 1 E 1 E N "_WindowText" E N "_Window" E E
 E E
17 0 0 0 0 0
E E E
0
3
LANG:10000 0 
LANG:10001 0 
LANG:10027 0 

0
4
LANG:10001 26 Arial,-1,13,5,50,0,0,0,0,0
LANG:10004 26 Arial,-1,13,5,50,0,0,0,0,0
LANG:10000 26 Arial,-1,13,5,50,0,0,0,0,0
LANG:10027 26 Arial,-1,13,5,50,0,0,0,0,0
0  8 167 502 461
"main()
{
  this.sortOnClick(FALSE);  
  this.alternatingRowColors(makeDynString(\"_AlternatingRowColorLight\",\"_AlternatingRowColorDark\"));
  
  dsDPEs = dpNames(\"*\", \"_AlertClass\");
  //IM 118248 prio and abbrevation in userDependingAlarm mapping panel
  dyn_string dsDPEPrior,dsDPEAbbr;
  dyn_char   dcPrior;
  dyn_langString dlAbbr;

  for(int i=1; i<=dynlen(dsDPEs); i++)
  {
    dsDPEs[i] = dpSubStr(dsDPEs[i], DPSUB_DP);
    dsDPEPrior[i] = dsDPEs[i]+\".:_alert_class.._prior\";//IM 118248 prio and abbrevation in userDependingAlarm mapping panel
    dsDPEAbbr[i]  = dsDPEs[i]+\".:_alert_class.._abbr\";//IM 118248 prio and abbrevation in userDependingAlarm mapping panel
  }
  //IM 118248 prio and abbrevation in userDependingAlarm mapping panel
  dpGet(dsDPEPrior,dcPrior,dsDPEAbbr,dlAbbr);
  bool bOK = (dynlen(dsDPEs) == dynlen(dcPrior)) && (dynlen(dcPrior) == dynlen(dlAbbr));
  
  if(bOK)
  {
    for(int i = 1; i <= dynlen(dsDPEs); i++)
    {
      string sPrior;
      
      sprintf(sPrior,\"%03d\",(int)dcPrior[i]);
      dsOrigs[i] = sPrior + \"_\" + dsDPEs[i] + \" (\" + dlAbbr[i] + \")\";
    }
  }
  dynSortAsc(dsOrigs);
  dsMapps = dsOrigs;
}

" 0
"main(int row, string column, string value)
{
  string sOriginal,sMapped;
  
  sOriginal = getClassFromIdent(this.cellValueRC(row,\"_origAC\"));
  sMapped   = getClassFromIdent(this.cellValueRC(row,\"_mappedAC\"));
  this.cellValueRC(row,\"origAC\") = sOriginal;
  this.cellValueRC(row,\"mappedAC\") = sMapped;
  
  value = getClassFromIdent(value);//get alert class name from alert class identifier e.g. get alert from 060_alert (A)
  
  if((sOriginal != \"\") || (sMapped != \"\"))
    this.cellFillRC(row,\"delete\",\"[pattern,[fit,any,StandardIcons/delete_20.png]]\");

  if(column == \"delete\")//column \"delete\" clicked 
  {
    this.deleteLineN(row);
    getIntoMapping(mDataNotToDelete,usrGrp.text());
  }
  else if(column == \"_origAC\")//left table side column == \"_origAC\"
  {
    string sValueR = getClassFromIdent(this.cellValueRC(row,\"_mappedAC\"));
    int ackTypeL,ackTypeR;
    
    if(dpExists(value)) 
    {
      dpGet(value+\".:_alert_class.._ack_type\",ackTypeL);
      if(sValueR != \"\")
      {
        if(dpExists(sValueR)) 
        {
          dpGet(sValueR+\".:_alert_class.._ack_type\",ackTypeR);
          dyn_anytype ds = ds = readAlertClasses(ackTypeR,\" >= \");
          int i = dynContains(ds,sValueR);
          if(i > 0)
            dynRemove(ds,i);
          for(int i = 1; i <= dynlen(ds); i++)
          {
            string s = ds[i];
            ds[i] = dynPatternMatch(\"*\"+s+\" (*\",dsOrigs);
          }
          dynSortAsc(ds);
          dynInsertAt(ds,FALSE,1);
          TABLE1.cellWidgetRC(row,\"_origAC\", \"ComboBox\", ds);
        }
      }
      setupTableRightSide(row,ackTypeL,value);
      if(ackTypeL < ackTypeR)
      {
        setValue(\"\",\"cellValueRC\",row,\"mappedAC\",\"\");
        setValue(\"\",\"cellValueRC\",row,\"_mappedAC\",\"\");
      }
    }
  }
  else//right table side column == \"_mappedAC\"
  {
     string sValueL = getClassFromIdent(this.cellValueRC(row,\"_origAC\"));
     string sValueR = getClassFromIdent(this.cellValueRC(row,\"_mappedAC\"));
     int ackTypeL,ackTypeR;

     if(dpExists(sValueR) && dpExists(sValueL))
     {
       dpGet(sValueL+\".:_alert_class.._ack_type\",ackTypeL,
             sValueR+\".:_alert_class.._ack_type\",ackTypeR);
       if(ackTypeR > ackTypeL)
       {
         setValue(\"\",\"cellValueRC\",row,\"mappedAC\",\"\",
                     \"cellValueRC\",row,\"_mappedAC\",\"\");
       }
     }
  }
  
  //refresh table
  if(this.lineCount() > 0)
  {  
    if(checkSelfAssignment(row))
    {
      deleteTableLines();
    }
    else if(checkOrigACforMultiples(sOriginal))
    {
      deleteTableLines();
    }
    else
    {
      deleteTableLines();
    }
  }
}



" 0
 1 0 1 5 0 "_origAC" 20 1 1 "s" 4
LANG:10001 20 Original alert class
LANG:10004 15 原始报警类
LANG:10000 21 Originale Alarmklasse
LANG:10027 61 Исходный (основной) класс алармов
E
3
LANG:10000 0 
LANG:10001 0 
LANG:10027 0 

233 "origAC" 20 0 0 "s" 4
LANG:10001 20 Original alert class
LANG:10004 15 原始报警类
LANG:10000 21 Originale Alarmklasse
LANG:10027 61 Исходный (основной) класс алармов
E
3
LANG:10000 0 
LANG:10001 0 
LANG:10027 0 

233 "_mappedAC" 20 1 1 "s" 4
LANG:10001 25 Userdependent alert class
LANG:10004 24 用户定义的报警类
LANG:10000 30 Benutzerabhängige Alarmklasse
LANG:10027 54 Дополнительный класс алармов
E
3
LANG:10000 0 
LANG:10001 0 
LANG:10027 0 

233 "mappedAC" 20 0 0 "s" 4
LANG:10001 25 Userdependent alert class
LANG:10004 24 用户定义的报警类
LANG:10000 30 Benutzerabhängige Alarmklasse
LANG:10027 54 Дополнительный класс алармов
E
3
LANG:10000 0 
LANG:10001 0 
LANG:10027 0 

233 "delete" 0 1 0 "s" 3
LANG:10000 13              
LANG:10001 15                
LANG:10027 16                 
E
3
LANG:10000 0 
LANG:10001 0 
LANG:10027 0 

17 
22 22 10 0
4
LANG:10001 26 Arial,-1,13,5,50,0,0,0,0,0
LANG:10004 26 Arial,-1,13,5,50,0,0,0,0,0
LANG:10000 26 Arial,-1,13,5,50,0,0,0,0,0
LANG:10027 26 Arial,-1,13,5,50,0,0,0,0,0
0 0 1 0 1 7
1 0
13 119
"PUSH_BUTTON1"
""
1 142 478 E E E 1 E 1 E N "_ButtonText" E N "_Button" E E
 E E
29 0 0 0 0 0
E E E
0
4
LANG:10001 22 Copy settings from ...
LANG:10004 18 从...复制设置
LANG:10000 30 Einstellungen kopieren von ...
LANG:10027 48 Копировать настройки из ...

0
4
LANG:10001 26 arial,-1,13,5,50,0,0,0,0,0
LANG:10004 26 arial,-1,13,5,50,0,0,0,0,0
LANG:10000 26 arial,-1,13,5,50,0,0,0,0,0
LANG:10027 26 arial,-1,13,5,50,0,0,0,0,0
0  142 478 230 506

T 
4
LANG:10001 9 Copy from
LANG:10004 9 复制自
LANG:10000 8 Kopieren
LANG:10027 15 Копия из
"main()
{
  dyn_string dsTarget = dpNames(\"_UserDependingAlarms_\"+usrGrp.text()+\".*:_original.._value\",\"_UserDependingAlarms\");
  
  if(dynlen(dsTarget))//Target DP already exists
  {
    dyn_anytype da;
    if(dpGet(dsTarget,da) != 0) return;//Error
    dyn_errClass dErr = getLastError();
    if(dynlen(dErr)) return;//Error, too
    
    for(int i = 1; i <= dynlen(dsTarget); i++)
    {
      if(patternMatch(\"*UserDependingAlarms_*.alarmClass:_original.._value\",dsTarget[i]))
      {
        if(dynlen(da[i]))//Target not empty
        {
          string s;
          dyn_string ds;
          dyn_float df;
          
          sprintf(s,getCatStr(\"usrDepAlarms\",\"00016\"),usrGrp.text());
          ChildPanelOnCentralModalReturn(\"vision/MessageWarning2\",myModuleName()+\"_UDA00016\",
                                         makeDynString(\"$1:\"+s,getCatStr(\"general\",\"yes\"),getCatStr(\"general\",\"no\")),df,ds);  
          if(!dynlen(df) || (df[1] != 1))//user pressed no
            return;//do not overwrite settings
        }
        break;//overwrite settings
      }
    }
  }
  else if(!dpExists(\"_UserDependingAlarms_\"+usrGrp.text()))
  {
    dpCreate(\"_UserDependingAlarms_\"+usrGrp.text(),\"_UserDependingAlarms\");
    dsTarget = dpNames(\"_UserDependingAlarms_\"+usrGrp.text()+\".*:_original.._value\",\"_UserDependingAlarms\");
  }
  //open popup
  dyn_float df;
  dyn_string ds;
  
  ChildPanelOnCentralModalReturn(\"para/UDA_popup.pnl\",myModuleName()+\"_\"+myPanelName()+\"_popup1\", 
                                 makeDynString(\"$1:\"+usrGrp.text()),df,ds);
  if(!dynlen(df) || (df[1] != 1)) return;//user pressed cancel
  
  dyn_string dsSource = dpNames(\"_UserDependingAlarms_\"+ds[1]+\".*:_original.._value\",\"_UserDependingAlarms\");
  dyn_anytype daSource;
  dyn_string dsOriginal,dsMapped;
  //copy settings - read from source first
  if(dynlen(dsSource) == 2)
  {
    if(dpGet(dsSource,daSource) != 0) return;//Error
    dyn_errClass dErr = getLastError();
    if(dynlen(dErr)) return;//Error, too
    for(int i = 1; i <= dynlen(dsTarget); i++)
    {
      if(patternMatch(\"*.alarmClass*\",dsSource[i])) 
        dsMapped = daSource[i];
      else if(patternMatch(\"*.originalAlarm*\",dsSource[i]))
        dsOriginal = daSource[i];
    }
  }
  else
    return;//inconsistent source
  if(dynlen(dsMapped) != dynlen(dsOriginal))
    return;//inconsistent source
  
  if(dynlen(dsTarget) == 2)//setup target with new values
  {
    mapping mEmpty;
    mData[dpSubStr(dsTarget[1],DPSUB_DP)] = mEmpty;//re-initialize
    for(int i = 1; i <= dynlen(dsTarget); i++)
    {
      if(patternMatch(\"*.alarmClass*\",dsTarget[i])) 
        mData[dpSubStr(dsTarget[1],DPSUB_DP)][\"mapped\"] = dsMapped;
      else if(patternMatch(\"*.originalAlarm*\",dsTarget[i]))
        mData[dpSubStr(dsTarget[1],DPSUB_DP)][\"original\"] = dsOriginal;
    }
    displayDataForUsrGrp(usrGrp.text());
    mDataKey = usrGrp.text();
  }
  //At this point nothing will be changed - press Apply or OK button to save changes
}

" 0
 E E E
0
LAYER, 1 
3
LANG:10000 0 
LANG:10001 0 
LANG:10027 0 
0
LAYER, 2 
3
LANG:10000 0 
LANG:10001 0 
LANG:10027 0 
0
LAYER, 3 
3
LANG:10000 0 
LANG:10001 0 
LANG:10027 0 
0
LAYER, 4 
3
LANG:10000 0 
LANG:10001 0 
LANG:10027 0 
0
LAYER, 5 
3
LANG:10000 0 
LANG:10001 0 
LANG:10027 0 
0
LAYER, 6 
3
LANG:10000 0 
LANG:10001 0 
LANG:10027 0 
0
LAYER, 7 
3
LANG:10000 0 
LANG:10001 0 
LANG:10027 0 
0
3 0 "PANEL_REF0" -1
"" ""
"objects_parts/STD_OBJECTS/ButtonBarBackground.pnl" 0 0 T 19 1.240480961923848 0 1 -105 470
0
0
